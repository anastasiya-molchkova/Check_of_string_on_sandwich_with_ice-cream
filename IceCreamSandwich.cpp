/* Сэндвич с мороженым — это строка, образованная двумя одинаковыми концами и разной серединой. 
   Левый и правый концы сэндвича идентичны как по длине, так и по повторяющимся символам. Середину состоит из одного, другого символа.
   В мороженом обязательно должна быть начинка, сэндвич с мороженым должен иметь минимальную длину 3 символа, и как минимум два из этих символов должны быть различны.
*/

#include <iostream>
#include <string>    // для std::string
#include <Windows.h> // для кириллицы

using std::cout; using std::cin; using std::endl;
using std::string;

// возвращает истину, если игрок хочет сыграть ещё раз и ложь, если не хочет
bool wantsContinue()
{
	cout << endl;
	cout << "Хотите сыграть ещё раз? Нажмите 'y', если да или 'n', если нет ";
	string answer{ "" };
	std::getline(cin, answer);
	while ((answer != "y") && (answer != "n"))
	{
		cout << "Ваш ответ не понятен! Хотите сыграть ещё раз? Нажмите 'y', если да или 'n', если нет ";
		std::getline(cin, answer);
	}
	cout << endl;
	if (answer == "y") return true;
	else return false;
}

// возвращает истину, если строка - сэндвич с мороженым
bool IsICsandwich(const string& string_to_check)
{
	const unsigned short length = string_to_check.length();  // константа - длина строки
	if (length < 3) return false;                            // слишком короткая строка, чтобы быть сэндвичем

	char IC = string_to_check[0]; // из этого должно состоять само мороженое без начинки

	unsigned short finish_index = 0; // будем запоминаить индекс, по которому выйдем из цикла
	// в цикле идём по символам строки до середины
	for (unsigned short index = 0; index < (length / 2); index++)  
	{
		finish_index = index;  //запоминаем индекc
		// сравниваем символ до середины с символом на том же месте после середины - первый с последним, второй - с предпоследним и т.д.
		if (string_to_check[index] != string_to_check[length - 1 - index]) return false; // концы не совпадают, а значит не сэндвич
		// если символы в начале и конце одинаковые, сравниваем, символ в начале всё ещё такой же, как и самый первый?
		if (string_to_check[index] != IC) // если нет, то будем считать, что это началась начинка
			break;                        // значит, выходим из цикла
	}

	char filling;   // будущий символ начинки
	if (string_to_check[finish_index] != IC) //если вышли из цикла выше по этому условию, то есть дошли до начинки
	{
		filling = string_to_check[finish_index]; // запомниаем, что за символ нам встретился под видом начинки, из этого должно состоять вся начинка
		// осталось проверить начинку на однородность, проверяем начиная с первого символа начинки до симметричного ему символа после середины
		for (unsigned short i = finish_index; i <= (length - 1 - finish_index); i++) // возможно, одна лишняя итерация тут есть
			if (string_to_check[i] != filling) return false; // если очередной символ того, что должна быть начинка, отличается от символа начинки, то начинка не однородна, а значит - не сэндвич
	}
	else // вышли из циклавыше, так как дошли до середины, а значит, мороженое или однородно или осталось проверить лишь один символ
		return (string_to_check[length / 2] != IC);

	// проверили всё, что нужно и не нашли причин в отказе
	return true;
}

int main()
{
	// подключаем возможность ввода-вывода на кириллице:
	SetConsoleCP(1251); 
	SetConsoleOutputCP(1251);

	string some_string{ "" };

	do //будем просить строку и проверять её на сэндвичество, пока пользователю не надоест
	{
		cout << "Введите, пожалуйста, строку: ";
		std::getline(cin, some_string);

		if (IsICsandwich(some_string))
			cout << "Введённая строка - мороженое-сэндвич!";
		else
			cout << "Введённая строка не похожа на мороженое-сэндвич!";
	}
	while (wantsContinue() == true);

	return 0;
}